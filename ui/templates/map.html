<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>{{ title }}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { width: 100%; height: 100vh; }
    .marker-badge {
      background: #1f2937;
      color: #fff;
      border: 2px solid #0ea5e9;
      width: 28px; height: 28px;
      border-radius: 999px;
      display: grid; place-items: center;
      font: 700 12px/1 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
    }
  </style>
</head>
<body>
<div id="map"></div>
<script>
  const startLat = {{ start_lat | tojson }};
  const startLon = {{ start_lon | tojson }};
  const route = {{ route_geojson | tojson }};
  const waypoints = {{ waypoints_json | default('[]') | tojson }};
  const osKey = {{ os_api_key | tojson }};

  const map = L.map('map', { zoomControl: true }).setView([startLat, startLon], 13);

  // Base layers
  const osRaster = L.tileLayer(`https://api.os.uk/maps/raster/v1/zxy/Light_3857/{z}/{x}/{y}.png?key=${osKey}`, {
    attribution: ' Ordnance Survey', maxZoom: 19
  });
  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors', maxZoom: 19
  });
  const openTopo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
    maxZoom: 17,
    attribution: 'Map data: &copy; OpenStreetMap contributors, SRTM | Map style: &copy; OpenTopoMap (CC-BY-SA)'
  });
  const cyclosm = L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {
    maxZoom: 20,
    attribution: '&copy; OpenStreetMap contributors | Layer: CyclOSM'
  });

  // Optional hillshade overlay (ESRI World Hillshade)
  const hillshade = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Hillshade/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles &copy; Esri', opacity: 0.35
  });

  const baseLayers = { 'OpenTopoMap': openTopo, 'CyclOSM': cyclosm, 'OS Raster': osRaster, 'OpenStreetMap': osm };
  const overlays = { 'Hillshade': hillshade };
  openTopo.addTo(map);
  L.control.layers(baseLayers, overlays, { position: 'topright', collapsed: true }).addTo(map);

  // Route GeoJSON
  // Casing (outer stroke)
  const routeCasing = L.geoJSON(route, { style: { color: '#ffffff', weight: 8, opacity: 0.85, lineCap: 'round', lineJoin: 'round' } }).addTo(map);
  // Main colored stroke (Outdooractive-like burgundy)
  const routeLine = L.geoJSON(route, { style: { color: '#7a0f2b', weight: 6, opacity: 0.95, lineCap: 'round', lineJoin: 'round' } }).addTo(map);

  // Direction arrows along the route (PolylineDecorator)
  try {
    const layers = routeLine.getLayers ? routeLine.getLayers() : [];
    const segments = [];
    layers.forEach(l => {
      const latlngs = l.getLatLngs();
      if (latlngs && latlngs.length) {
        // Handle MultiLineString (array of arrays)
        if (Array.isArray(latlngs[0])) {
          latlngs.forEach(seg => segments.push(L.polyline(seg)));
        } else {
          segments.push(L.polyline(latlngs));
        }
      }
    });
    segments.forEach(seg => {
      L.polylineDecorator(seg, {
        patterns: [
          { offset: 25, repeat: 200, symbol: L.Symbol.arrowHead({ pixelSize: 10, polygon: false, pathOptions: { stroke: true, color: '#111827', weight: 3, opacity: 0.9 } }) }
        ]
      }).addTo(map);
    });
  } catch (e) { /* ignore */ }

  // Optional waypoint markers
  try {
    if (Array.isArray(waypoints)) {
      waypoints.forEach(function (pt, idx) {
        if (Array.isArray(pt) && pt.length === 2) {
          const icon = L.divIcon({ className: 'marker-badge', html: String(idx + 1) });
          L.marker([pt[0], pt[1]], { icon }).addTo(map);
        }
      });
    }
  } catch (e) { /* ignore */ }

  // Fit map to route if possible (including waypoints)
  try {
    const group = L.featureGroup([routeCasing, ...waypoints.map(pt => L.marker([pt[0], pt[1]]))]);
    const bounds = group.getBounds();
    if (bounds && bounds.isValid()) map.fitBounds(bounds.pad(0.12));
  } catch (e) {
    // ignore fit errors
  }
</script>
</body>
</html>
